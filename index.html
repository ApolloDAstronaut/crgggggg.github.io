<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Duck vs. IMT Lazarus (with AI)</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Press Start 2P', cursive; background-color: #1a202c; color: #e2e8f0; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
        canvas { background-color: #87ceeb; display: block; border: 4px solid #4a5568; border-radius: 8px; box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
        #game-container { display: flex; flex-direction: column; align-items: center; gap: 1rem; }
        .ui-panel { display: flex; justify-content: space-between; align-items: center; width: 800px; padding: 10px; background-color: #2d3748; border-radius: 8px; border: 4px solid #4a5568; }
        #message-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.8); color: white; padding: 2rem; border-radius: 1rem; text-align: center; font-size: 1.5rem; z-index: 100; display: none; border: 4px solid #a0aec0; min-width: 400px; }
        .button { background-color: #48bb78; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer; border-bottom: 4px solid #2f855a; transition: all 0.1s ease-in-out; font-size: 1rem; }
        .button:hover { transform: translateY(2px); border-bottom-width: 2px; }
        #physics-controls { display: flex; gap: 1rem; align-items: center; font-size: 0.7rem; }
        input[type="range"] { -webkit-appearance: none; width: 100px; height: 8px; background: #4a5568; border-radius: 5px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 18px; height: 18px; background: #a0aec0; border-radius: 50%; cursor: pointer; }
        #level-select { background-color: #4a5568; border: 2px solid #a0aec0; border-radius: 4px; color: white; padding: 4px; font-family: 'Press Start 2P', cursive; }
        /* Invisible toggle area top-left */
        #ai-toggle { position: absolute; top: 6px; left: 6px; width: 36px; height: 36px; opacity: 0; z-index: 200; cursor: pointer; }
        /* Small AI overlay when active */
        #ai-overlay { position: absolute; top: 8px; left: 8px; padding: 8px; background: rgba(0,0,0,0.6); color: #e2e8f0; border-radius: 6px; font-size: 12px; z-index: 201; display: none; }
    </style>
</head>
<body>

<div id="game-container">
    <h1 class="text-3xl mb-2">Weather Duck vs. IMT Lazarus</h1>
    <div id="ui-container" class="ui-panel">
        <div id="timer" class="text-xl">Time: 0.000s</div>
        <div class="text-lg">Controls: A/D or ←/→, W or ↑, R to restart</div>
    </div>
    <div id="controls-container" class="ui-panel">
        <div id="physics-controls">
            <label>Gravity: <span id="gravity-value">1.2</span><input type="range" id="gravity-slider" min="0.1" max="2" step="0.1" value="1.2"></label>
            <label>Jump: <span id="jump-value">18</span><input type="range" id="jump-slider" min="5" max="25" step="1" value="18"></label>
            <label>Speed: <span id="speed-value">12</span><input type="range" id="speed-slider" min="1" max="12" step="1" value="12"></label>
        </div>
        <div id="level-controls">
            <label for="level-select">Level:</label>
            <select id="level-select"></select>
        </div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="message-box">
        <p id="message-text"></p>
        <div class="flex justify-center gap-4 mt-4">
             <button id="restart-button" class="button">Play Again</button>
             <button id="next-level-button" class="button" style="display: none;">Next Level</button>
        </div>
    </div>
</div>

<!-- Invisible toggle in top-left. Click it to toggle AI on/off. -->
<div id="ai-toggle" title="Toggle AI"></div>
<div id="ai-overlay">AI: Off</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const timerElement = document.getElementById('timer');
    const messageBox = document.getElementById('message-box');
    const messageText = document.getElementById('message-text');
    const restartButton = document.getElementById('restart-button');
    const nextLevelButton = document.getElementById('next-level-button');
    const levelSelect = document.getElementById('level-select');
    const gravitySlider = document.getElementById('gravity-slider');
    const jumpSlider = document.getElementById('jump-slider');
    const speedSlider = document.getElementById('speed-slider');
    const gravityValue = document.getElementById('gravity-value');
    const jumpValue = document.getElementById('jump-value');
    const speedValue = document.getElementById('speed-value');
    const aiToggle = document.getElementById('ai-toggle');
    const aiOverlay = document.getElementById('ai-overlay');

    const PLAYER_WIDTH = 40;
    const PLAYER_HEIGHT = 40;
    const MS_PER_UPDATE = 1000 / 39;

    let GRAVITY = 1.2;
    let JUMP_FORCE = -18;
    let PLAYER_SPEED = 12;

    let player, platforms, hazards, goal, keys, timer, gameRunning, currentLevelIndex;
    let startTime = null; let pauseStartTime = null;
    let lastTime = 0; let lag = 0.0; let rKeyTimeout = null;

    // Levels array (same as before) - omitted here for brevity in this comment but included below.
    const levels = [ /* LEVELS from original file - same content copied here */
        { start: {x:50,y:520}, layout:[{x:0,y:580,width:800,height:20,type:'platform'},{x:200,y:500,width:100,height:20,type:'platform'},{x:350,y:420,width:100,height:20,type:'platform'},{x:200,y:340,width:80,height:20,type:'platform'},{x:400,y:280,width:20,height:20,type:'platform'},{x:500,y:220,width:100,height:20,type:'platform'},{x:0,y:200,width:300,height:20,type:'hazard'},{x:50,y:180,width:50,height:20,type:'platform'},{x:200,y:140,width:50,height:20,type:'platform'},{x:400,y:100,width:250,height:20,type:'platform'},{x:700,y:50,width:100,height:20,type:'platform',goal:true}] },
        { start:{x:20,y:520}, layout:[{x:0,y:580,width:150,height:20,type:'platform'},{x:250,y:540,width:100,height:20,type:'platform'},{x:450,y:500,width:100,height:20,type:'platform'},{x:650,y:460,width:150,height:20,type:'platform'},{x:550,y:360,width:50,height:20,type:'platform'},{x:350,y:300,width:50,height:20,type:'platform'},{x:150,y:240,width:50,height:20,type:'platform'},{x:0,y:180,width:100,height:20,type:'platform',goal:true}] },
        { start:{x:20,y:520}, layout:[{x:0,y:580,width:100,height:20,type:'platform'},{x:150,y:520,width:50,height:20,type:'platform'},{x:30,y:460,width:50,height:20,type:'platform'},{x:150,y:400,width:50,height:20,type:'platform'},{x:30,y:340,width:50,height:20,type:'platform'},{x:180,y:280,width:50,height:20,type:'platform'},{x:350,y:220,width:150,height:20,type:'platform'},{x:600,y:160,width:50,height:20,type:'platform'},{x:750,y:100,width:50,height:20,type:'platform',goal:true}] },
        { start:{x:20,y:400}, layout:[{x:0,y:580,width:800,height:20,type:'hazard'},{x:0,y:450,width:100,height:20,type:'platform'},{x:150,y:420,width:20,height:20,type:'platform'},{x:220,y:420,width:20,height:20,type:'platform'},{x:290,y:420,width:20,height:20,type:'platform'},{x:380,y:380,width:100,height:20,type:'platform'},{x:380,y:360,width:20,height:20,type:'hazard'},{x:550,y:320,width:100,height:20,type:'platform'},{x:700,y:260,width:100,height:20,type:'platform'},{x:550,y:200,width:100,height:20,type:'platform'},{x:380,y:140,width:100,height:20,type:'platform'},{x:200,y:80,width:80,height:20,type:'platform',goal:true}] },
        { start:{x:380,y:520}, layout:[{x:350,y:580,width:100,height:20,type:'platform'},{x:350,y:500,width:100,height:20,type:'platform'},{x:250,y:440,width:300,height:20,type:'platform'},{x:250,y:380,width:50,height:20,type:'platform'},{x:150,y:320,width:50,height:20,type:'platform'},{x:0,y:260,width:100,height:20,type:'hazard'},{x:500,y:380,width:50,height:20,type:'platform'},{x:600,y:320,width:50,height:20,type:'platform'},{x:700,y:260,width:100,height:20,type:'platform'},{x:700,y:200,width:50,height:20,type:'platform'},{x:550,y:140,width:100,height:20,type:'platform'},{x:350,y:80,width:100,height:20,type:'platform',goal:true}] },
        { start:{x:20,y:520}, layout:[{x:0,y:580,width:80,height:20,type:'platform'},{x:120,y:550,width:15,height:20,type:'platform'},{x:180,y:520,width:15,height:20,type:'platform'},{x:240,y:490,width:15,height:20,type:'platform'},{x:180,y:430,width:15,height:20,type:'platform'},{x:240,y:370,width:15,height:20,type:'platform'},{x:350,y:370,width:100,height:20,type:'platform'},{x:500,y:400,width:15,height:20,type:'hazard'},{x:550,y:340,width:15,height:20,type:'platform'},{x:600,y:280,width:15,height:20,type:'platform'},{x:680,y:220,width:120,height:20,type:'platform',goal:true}] },
        { start:{x:380,y:20}, layout:[{x:350,y:80,width:100,height:20,type:'platform'},{x:200,y:180,width:80,height:20,type:'platform'},{x:500,y:180,width:80,height:20,type:'platform'},{x:0,y:250,width:360,height:10,type:'hazard'},{x:440,y:250,width:360,height:10,type:'hazard'},{x:350,y:320,width:100,height:20,type:'platform'},{x:50,y:400,width:100,height:20,type:'platform'},{x:650,y:400,width:100,height:20,type:'platform'},{x:0,y:580,width:350,height:20,type:'platform'},{x:450,y:580,width:350,height:20,type:'platform'},{x:380,y:520,width:40,height:20,type:'platform',goal:true}] },
        { start:{x:20,y:520}, layout:[{x:0,y:580,width:800,height:20,type:'hazard'},{x:0,y:560,width:50,height:20,type:'platform'},{x:100,y:500,width:50,height:20,type:'platform'},{x:50,y:440,width:20,height:20,type:'hazard'},{x:200,y:420,width:100,height:20,type:'platform'},{x:350,y:360,width:100,height:20,type:'platform'},{x:250,y:300,width:20,height:20,type:'hazard'},{x:450,y:280,width:50,height:20,type:'platform'},{x:600,y:220,width:50,height:20,type:'platform'},{x:750,y:160,width:50,height:20,type:'platform'},{x:600,y:100,width:50,height:20,type:'platform',goal:true}] },
        { start:{x:20,y:520}, layout:[{x:0,y:580,width:800,height:20,type:'platform'},{x:100,y:540,width:600,height:10,type:'hazard'},{x:150,y:500,width:20,height:20,type:'platform'},{x:200,y:460,width:20,height:20,type:'platform'},{x:250,y:500,width:20,height:20,type:'platform'},{x:300,y:460,width:20,height:20,type:'platform'},{x:350,y:500,width:20,height:20,type:'platform'},{x:400,y:460,width:200,height:20,type:'platform'},{x:650,y:420,width:50,height:20,type:'platform'},{x:750,y:380,width:50,height:20,type:'platform'},{x:650,y:320,width:50,height:20,type:'platform'},{x:750,y:260,width:50,height:20,type:'platform'},{x:400,y:200,width:300,height:20,type:'platform'},{x:100,y:150,width:200,height:20,type:'platform',goal:true}] },
        { start:{x:380,y:520}, layout:[{x:0,y:580,width:800,height:20,type:'hazard'},{x:350,y:560,width:100,height:20,type:'platform'},{x:250,y:480,width:50,height:20,type:'platform'},{x:450,y:480,width:50,height:20,type:'platform'},{x:100,y:400,width:100,height:10,type:'hazard'},{x:600,y:400,width:100,height:10,type:'hazard'},{x:350,y:380,width:100,height:20,type:'platform'},{x:150,y:300,width:15,height:20,type:'platform'},{x:550,y:300,width:15,height:20,type:'platform'},{x:350,y:220,width:15,height:20,type:'platform'},{x:0,y:150,width:250,height:20,type:'platform'},{x:550,y:150,width:250,height:20,type:'platform'},{x:300,y:80,width:200,height:20,type:'platform',goal:true}] }
    ];

    const playerProto = {
        x: 100, y: 500, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, velocityX: 0, velocityY: 0, onGround: false,
        draw() {
            ctx.fillStyle = '#FFD700'; ctx.fillRect(this.x, this.y, this.width, this.height);
            ctx.fillStyle = '#FFA500'; const beakX = this.velocityX >= 0 ? this.x + this.width : this.x - 10; ctx.fillRect(beakX, this.y + this.height * 0.5, 10, 5);
            ctx.fillStyle = '#000000'; const eyeX = this.velocityX > 0 ? this.x + this.width * 0.7 : this.x + this.width * 0.2; ctx.fillRect(eyeX, this.y + this.height * 0.2, 5, 5);
        },
        update() {
            if (!aiActive) {
                if (keys['a'] || keys['ArrowLeft']) this.velocityX = -PLAYER_SPEED;
                else if (keys['d'] || keys['ArrowRight']) this.velocityX = PLAYER_SPEED;
                else this.velocityX = 0;
                if ((keys['w'] || keys['ArrowUp']) && this.onGround) { this.velocityY = JUMP_FORCE; this.onGround = false; }
            } else {
                // AI will set aiActions global before update
                this.velocityX = aiActions.left ? -PLAYER_SPEED : (aiActions.right ? PLAYER_SPEED : 0);
                if (aiActions.jump && this.onGround) { this.velocityY = JUMP_FORCE; this.onGround = false; }
            }

            if (this.velocityY < 0 && !(keys['w'] || keys['ArrowUp'])) { this.velocityY += GRAVITY * 2.5; }
            else { this.velocityY += GRAVITY; }

            this.x += this.velocityX; this.y += this.velocityY; this.onGround = false;
            if (this.x < 0) this.x = 0; if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
            if (this.y > canvas.height) endGame(false);
        }
    };

    function drawGameObjects() {
        ctx.fillStyle = '#654321'; platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height));
        ctx.fillStyle = '#FF0000'; hazards.forEach(h => ctx.fillRect(h.x, h.y, h.width, h.height));
        ctx.save(); ctx.fillStyle = '#4B0082'; ctx.shadowColor = 'rgba(255, 0, 255, 0.7)'; ctx.shadowBlur = 15;
        ctx.fillRect(goal.x, goal.y - 50, goal.width, goal.height + 50);
        ctx.fillStyle = '#FF00FF'; ctx.fillRect(goal.x + 10, goal.y - 35, 10, 10); ctx.fillRect(goal.x + goal.width - 20, goal.y - 35, 10, 10); ctx.restore();
    }

    function checkCollisions() {
        platforms.forEach(p => {
            if (player.x < p.x + p.width && player.x + player.width > p.x && player.y < p.y + p.height && player.y + player.height > p.y && player.velocityY >= 0 && player.y + player.height - player.velocityY <= p.y + 1) {
                player.y = p.y - player.height; player.velocityY = 0; player.onGround = true;
            }
        });
        hazards.forEach(h => { if (player.x < h.x + h.width && player.x + player.width > h.x && player.y < h.y + h.height && player.y + player.height > h.y) { endGame(false); } });
        if (player.x < goal.x + goal.width && player.x + player.width > goal.x && player.y < goal.y + goal.height && player.y + player.height > goal.y) { endGame(true); }
    }

    function updateGame() { player.update(); checkCollisions(); }

    function renderGame() {
        let timePassed = 0; if (startTime) timePassed = (new Date() - startTime) / 1000; timer = timePassed; timerElement.textContent = `Time: ${timePassed.toFixed(3)}s`;
        ctx.clearRect(0,0,canvas.width,canvas.height); drawGameObjects(); player.draw();
    }

    function gameLoop(currentTime) {
        if (!gameRunning) { lastTime = 0; return; }
        if (lastTime === 0) lastTime = currentTime;
        const elapsed = currentTime - lastTime; lastTime = currentTime; lag += elapsed;
        while (lag >= MS_PER_UPDATE) { updateGame(); lag -= MS_PER_UPDATE; }
        renderGame(); requestAnimationFrame(gameLoop);
    }

    function loadLevel(levelIndex) {
        if (pauseStartTime && startTime) { const pausedDuration = new Date() - pauseStartTime; startTime.setTime(startTime.getTime() + pausedDuration); pauseStartTime = null; }
        currentLevelIndex = levelIndex; const levelData = levels[levelIndex];
        player = Object.create(playerProto); player.x = levelData.start.x; player.y = levelData.start.y; player.velocityX = 0; player.velocityY = 0; player.onGround = false;
        platforms = levelData.layout.filter(item => item.type === 'platform'); hazards = levelData.layout.filter(item => item.type === 'hazard');
        const goalPlatform = levelData.layout.find(item => item.goal); goal = { x: goalPlatform.x + goalPlatform.width/2 - 20, y: goalPlatform.y - 50, width: 40, height: 50 };
        keys = {}; gameRunning = true; messageBox.style.display = 'none'; nextLevelButton.style.display = 'none'; restartButton.textContent = 'Play Again'; levelSelect.selectedIndex = levelIndex;
        lastTime = 0; lag = 0.0; requestAnimationFrame(gameLoop);
    }

    function endGame(win) {
        if (!gameRunning) return; gameRunning = false; pauseStartTime = new Date();
        if (win) { const isLastLevel = currentLevelIndex === levels.length - 1; messageText.innerHTML = isLastLevel ? `YOU BEAT THE GAME!<br>Final Time: ${timer.toFixed(3)}s` : `LEVEL ${currentLevelIndex + 1} COMPLETE!<br>Time: ${timer.toFixed(3)}s`; messageBox.style.borderColor = '#48bb78'; if (isLastLevel) restartButton.textContent = 'New Game'; else nextLevelButton.style.display = 'inline-block'; }
        else { messageText.innerHTML = `GAME OVER!<br>Try again!`; messageBox.style.borderColor = '#e53e3e'; }
        messageBox.style.display = 'block';
    }

    function resetGame() { startTime = null; pauseStartTime = null; timerElement.textContent = 'Time: 0.000s'; loadLevel(0); }

    function setupUI() {
        levels.forEach((_, index) => { const option = document.createElement('option'); option.value = index; option.textContent = `Level ${index+1}`; levelSelect.appendChild(option); });
        levelSelect.addEventListener('change', (e) => { resetGame(); loadLevel(parseInt(e.target.value)); });
        gravitySlider.addEventListener('input', (e) => { GRAVITY = parseFloat(e.target.value); gravityValue.textContent = GRAVITY.toFixed(1); });
        jumpSlider.addEventListener('input', (e) => { JUMP_FORCE = -parseFloat(e.target.value); jumpValue.textContent = e.target.value; });
        speedSlider.addEventListener('input', (e) => { PLAYER_SPEED = parseFloat(e.target.value); speedValue.textContent = e.target.value; });
        restartButton.addEventListener('click', () => { if (restartButton.textContent === 'New Game') resetGame(); else loadLevel(currentLevelIndex); });
        nextLevelButton.addEventListener('click', () => loadLevel(currentLevelIndex + 1));

        window.addEventListener('keydown', e => { if (aiActive) return; const key = e.key.toLowerCase(); keys[key] = true; keys[e.key] = true; if (gameRunning && !startTime && ['w','a','d','arrowup','arrowleft','arrowright'].includes(key)) startTime = new Date(); if (key === 'r' && !e.repeat) { rKeyTimeout = setTimeout(() => { resetGame(); rKeyTimeout = null; }, 600); } });
        window.addEventListener('keyup', e => { if (aiActive) return; const key = e.key.toLowerCase(); keys[key] = false; keys[e.key] = false; if (key === 'r') { if (rKeyTimeout) { clearTimeout(rKeyTimeout); loadLevel(currentLevelIndex); rKeyTimeout = null; } } });
    }

    // ------------------- AI: simple neuroevolution -------------------
    let aiActive = false; let aiPopulation = []; let aiConfig = { popSize: 30, hidden: 8, inputSize: 8, outputSize: 3, mutateRate: 0.2, mutateStep: 0.4 }; let aiCurrent = 0; let aiGeneration = 0; let aiBest = null; let aiActions = { left:false, right:false, jump:false }; let aiRunning = false;

    function sigmoid(x) { return 1/(1+Math.exp(-x)); }
    function tanh(x) { return Math.tanh(x); }

    function makeGenome() {
        const inN = aiConfig.inputSize; const h = aiConfig.hidden; const out = aiConfig.outputSize; const w = [];
        // input->hidden
        for (let i=0;i<(inN*h);i++) w.push((Math.random()*2-1));
        // hidden biases
        for (let i=0;i<h;i++) w.push((Math.random()*2-1));
        // hidden->out
        for (let i=0;i<(h*out);i++) w.push((Math.random()*2-1));
        // out biases
        for (let i=0;i<out;i++) w.push((Math.random()*2-1));
        return { weights: w, fitness: 0 };
    }

    function forwardNN(weights, inputs) {
        const inN = aiConfig.inputSize; const h = aiConfig.hidden; const out = aiConfig.outputSize;
        let idx = 0; const hidden = new Array(h).fill(0);
        for (let i=0;i<h;i++) {
            let sum = 0; for (let j=0;j<inN;j++) { sum += inputs[j]*weights[idx++]; }
            sum += weights[idx++]; hidden[i] = tanh(sum);
        }
        const outputs = new Array(out).fill(0);
        for (let k=0;k<out;k++) { let sum = 0; for (let i=0;i<h;i++) { sum += hidden[i]*weights[idx++]; } sum += weights[idx++]; outputs[k] = sum; }
        return outputs.map(x => sigmoid(x));
    }

    function mutateGenome(g) {
        const w = g.weights.slice(); for (let i=0;i<w.length;i++) { if (Math.random() < aiConfig.mutateRate) w[i] += (Math.random()*2-1)*aiConfig.mutateStep; }
        return { weights: w, fitness: 0 };
    }

    function crossover(a,b) { const w = []; for (let i=0;i<a.weights.length;i++) w.push(Math.random()<0.5 ? a.weights[i] : b.weights[i]); return { weights: w, fitness: 0 } }

    // get simple sensory inputs: normalized distances to goal, nearest platform/hazard under/around etc.
    function senseEnvironment(simPlayer) {
        const inputs = [];
        // normalized x,y to goal
        const gx = (goal.x + goal.width/2 - (simPlayer.x + simPlayer.width/2))/canvas.width;
        const gy = (goal.y + goal.height/2 - (simPlayer.y + simPlayer.height/2))/canvas.height;
        inputs.push(gx); inputs.push(gy);
        // velocity
        inputs.push(simPlayer.velocityX/20); inputs.push(simPlayer.velocityY/50);
        // onGround
        inputs.push(simPlayer.onGround?1:0);
        // nearest platform delta x,y beneath player
        let nearestDy = 9999; let nearestDx = 0;
        platforms.forEach(p => { if (p.x - simPlayer.x < 300 && p.x - simPlayer.x > -300) {
            const dy = p.y - simPlayer.y; const dx = (p.x + p.width/2) - (simPlayer.x + simPlayer.width/2);
            if (dy >= -200 && Math.abs(dx) < 400 && Math.abs(dy) < Math.abs(nearestDy)) { nearestDy = dy; nearestDx = dx; }
        }});
        inputs.push(nearestDx/400); inputs.push(nearestDy/600);
        // pad/truncate to inputSize
        while (inputs.length < aiConfig.inputSize) inputs.push(0);
        return inputs.slice(0, aiConfig.inputSize);
    }

    // Simulate one genome on current level until death/goal/maxSteps. Non-blocking: run step-by-step interleaved with main loop.
    let aiEvalState = null;
    function startEvalGenome(genome) {
        // clone level state
        const sim = { player: Object.assign({}, player, { x: player.x, y: player.y, velocityX: player.velocityX, velocityY: player.velocityY, onGround: player.onGround }), steps:0, maxSteps: 4000, done:false };
        aiEvalState = { genome, sim, fitness:0 };
    }

    function stepEval() {
        if (!aiEvalState) return true;
        const { genome, sim } = aiEvalState;
        if (sim.done) return true;
        // sense
        const inputs = senseEnvironment(sim.player);
        const out = forwardNN(genome.weights, inputs);
        // map outputs to actions
        const left = out[0] > 0.5; const right = out[0] < 0.5 && out[1] > 0.6; const jump = out[2] > 0.6;
        // update sim player
        sim.player.velocityX = left ? -PLAYER_SPEED : (right ? PLAYER_SPEED : 0);
        if (jump && sim.player.onGround) { sim.player.velocityY = JUMP_FORCE; sim.player.onGround = false; }
        if (sim.player.velocityY < 0 && !jump) sim.player.velocityY += GRAVITY*2.5; else sim.player.velocityY += GRAVITY;
        sim.player.x += sim.player.velocityX; sim.player.y += sim.player.velocityY;
        // collisions simplified: stand on platforms
        sim.player.onGround = false;
        for (let p of platforms) {
            if (sim.player.x < p.x + p.width && sim.player.x + sim.player.width > p.x && sim.player.y < p.y + p.height && sim.player.y + sim.player.height > p.y && sim.player.velocityY >= 0 && sim.player.y + sim.player.height - sim.player.velocityY <= p.y + 1) {
                sim.player.y = p.y - sim.player.height; sim.player.velocityY = 0; sim.player.onGround = true;
            }
        }
        // hazards check
        for (let h of hazards) { if (sim.player.x < h.x + h.width && sim.player.x + sim.player.width > h.x && sim.player.y < h.y + h.height && sim.player.y + sim.player.height > h.y) { sim.done = true; aiEvalState.fitness = evaluateFitness(sim.player, false, sim.steps); return true; } }
        // goal
        if (sim.player.x < goal.x + goal.width && sim.player.x + sim.player.width > goal.x && sim.player.y < goal.y + goal.height && sim.player.y + sim.player.height > goal.y) { sim.done = true; aiEvalState.fitness = evaluateFitness(sim.player, true, sim.steps); return true; }
        // bounds
        if (sim.player.y > canvas.height) { sim.done = true; aiEvalState.fitness = evaluateFitness(sim.player, false, sim.steps); return true; }
        sim.steps++;
        if (sim.steps > sim.maxSteps) { sim.done = true; aiEvalState.fitness = evaluateFitness(sim.player, false, sim.steps); return true; }
        // not done yet
        return false;
    }

    function evaluateFitness(simPlayer, reachedGoal, steps) {
        // fitness favors reaching goal quickly and getting closer to goal
        const dx = Math.abs((goal.x + goal.width/2) - (simPlayer.x + simPlayer.width/2));
        const dy = Math.abs((goal.y + goal.height/2) - (simPlayer.y + simPlayer.height/2));
        const dist = Math.sqrt(dx*dx + dy*dy);
        let f = 10000 / (1 + dist) + (reachedGoal ? 5000 - steps : 0) + (simPlayer.onGround?50:0);
        return f;
    }

    function startAI() {
        if (aiRunning) return; aiActive = true; aiRunning = true; aiOverlay.style.display = 'block'; aiOverlay.textContent = 'AI: Training...';
        // initialize population
        aiPopulation = []; for (let i=0;i<aiConfig.popSize;i++) aiPopulation.push(makeGenome()); aiCurrent = 0; aiGeneration = 0; aiBest = null;
        // start evaluating first genome
        startEvalGenome(aiPopulation[aiCurrent]);
    }

    function stopAI() { aiActive = false; aiRunning = false; aiOverlay.textContent = 'AI: Off'; aiOverlay.style.display = 'block'; setTimeout(()=>{ if(!aiActive) aiOverlay.style.display='none'; },1500); }

    // Integrate AI stepping into main loop (non-blocking): call stepEval every frame a few times
    const AI_STEPS_PER_FRAME = 6;
    function aiFrameStep() {
        if (!aiRunning) return;
        // if nothing to eval, create next generation
        if (!aiEvalState) {
            startEvalGenome(aiPopulation[aiCurrent]);
        }
        let finished = false;
        for (let i=0;i<AI_STEPS_PER_FRAME;i++) { finished = stepEval() || finished; if (finished) break; }
        if (aiEvalState && aiEvalState.sim.done) {
            aiPopulation[aiCurrent].fitness = aiEvalState.fitness;
            // update best
            if (!aiBest || aiPopulation[aiCurrent].fitness > aiBest.fitness) { aiBest = { weights: aiPopulation[aiCurrent].weights.slice(), fitness: aiPopulation[aiCurrent].fitness }; }
            // advance
            aiCurrent++;
            aiEvalState = null;
            if (aiCurrent >= aiPopulation.length) {
                // generation finished -> evolve
                aiPopulation.sort((a,b)=>b.fitness-a.fitness);
                // keep top 20%
                const survivors = aiPopulation.slice(0, Math.max(2, Math.floor(aiPopulation.length*0.2)));
                const newPop = survivors.slice();
                while (newPop.length < aiPopulation.length) {
                    const a = survivors[Math.floor(Math.random()*survivors.length)];
                    const b = survivors[Math.floor(Math.random()*survivors.length)];
                    const child = mutateGenome(crossover(a,b)); newPop.push(child);
                }
                aiPopulation = newPop; aiGeneration++;
                aiCurrent = 0;
                aiOverlay.textContent = `AI: Gen ${aiGeneration} Best ${Math.round(aiBest.fitness)}`;
                // if best reached very high fitness assume solved and switch to play mode
                if (aiBest && aiBest.fitness > 14000) {
                    aiOverlay.textContent = `AI: Training complete. Playing.`; aiRunning = false; // training done
                    // set best as controller
                    aiController = { weights: aiBest.weights.slice() };
                }
            }
        }
    }

    // Controller used while aiActive (after or during training)
    let aiController = null;
    function aiControlStep() {
        if (!aiActive) return;
        if (aiRunning) return; // training in progress
        // if we have a trained controller use it, otherwise use best so far
        const ctrl = aiController || (aiBest ? { weights: aiBest.weights } : aiPopulation[0]);
        if (!ctrl) return;
        const inputs = senseEnvironment(player);
        const out = forwardNN(ctrl.weights, inputs);
        const left = out[0] > 0.55; const right = out[1] > 0.55; const jump = out[2] > 0.6;
        aiActions.left = left; aiActions.right = right; aiActions.jump = jump;
    }

    // hook into main animation to run AI steps
    const originalRequestAnimationFrame = window.requestAnimationFrame;
    function wrappedRAF(cb) {
        return originalRequestAnimationFrame(function(t) {
            aiFrameStep(); aiControlStep(); cb(t);
        });
    }
    // override requestAnimationFrame used in loadLevel
    window.requestAnimationFrame = wrappedRAF;

    // toggle behavior
    aiToggle.addEventListener('click', () => {
        if (!aiActive) { startAI(); } else { stopAI(); }
    });

    // init
    setupUI(); loadLevel(0);

    // expose small status via overlay
    setInterval(()=>{ if (aiActive) { if (aiRunning) { aiOverlay.textContent = `AI: Training Gen ${aiGeneration} Eval ${aiCurrent}/${aiPopulation.length}`; } else { aiOverlay.textContent = `AI: Playing Gen ${aiGeneration} Best ${aiBest?Math.round(aiBest.fitness):0}`; } aiOverlay.style.display='block'; } }, 500);

</script>

</body>
</html>
